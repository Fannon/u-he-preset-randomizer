import {
  getRandomArrayItem,
  calculateRandomMergeRatios,
  getPresetDescriptionSuffix,
} from '../src/randomizer.js';
import { getDefaultConfig, type Config } from '../src/config.js';
import { jest } from '@jest/globals';

describe('randomizer', () => {
  describe('getRandomArrayItem', () => {
    it('should return an item from the array', () => {
      const array = [1, 2, 3, 4, 5];
      const result = getRandomArrayItem(array);

      expect(array).toContain(result);
    });

    it('should work with string arrays', () => {
      const array = ['a', 'b', 'c'];
      const result = getRandomArrayItem(array);

      expect(array).toContain(result);
    });

    it('should work with object arrays', () => {
      const array = [{ id: 1 }, { id: 2 }, { id: 3 }];
      const result = getRandomArrayItem(array);

      expect(array).toContain(result);
    });

    it('should handle single-element arrays', () => {
      const array = [42];
      const result = getRandomArrayItem(array);

      expect(result).toBe(42);
    });

    it('should return different values over multiple calls (probabilistic)', () => {
      const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
      const results = new Set();

      // Call 100 times to get statistical variation
      for (let i = 0; i < 100; i++) {
        results.add(getRandomArrayItem(array));
      }

      // With 10 items and 100 calls, we should get multiple different values
      expect(results.size).toBeGreaterThan(1);
    });
  });

  describe('calculateRandomMergeRatios', () => {
    it('should return ratios that sum to 1', () => {
      const ratios = calculateRandomMergeRatios(3);

      expect(ratios).toHaveLength(3);

      const sum = ratios.reduce((acc, val) => acc + val, 0);
      expect(sum).toBeCloseTo(1.0, 10);
    });

    it('should return all positive ratios', () => {
      const ratios = calculateRandomMergeRatios(5);

      ratios.forEach(ratio => {
        expect(ratio).toBeGreaterThan(0);
        expect(ratio).toBeLessThan(1);
      });
    });

    it('should handle 2 presets', () => {
      const ratios = calculateRandomMergeRatios(2);

      expect(ratios).toHaveLength(2);
      expect(ratios[0] + ratios[1]).toBeCloseTo(1.0, 10);
    });

    it('should handle single preset', () => {
      const ratios = calculateRandomMergeRatios(1);

      expect(ratios).toHaveLength(1);
      expect(ratios[0]).toBeCloseTo(1.0, 10);
    });

    it('should handle many presets', () => {
      const ratios = calculateRandomMergeRatios(10);

      expect(ratios).toHaveLength(10);

      const sum = ratios.reduce((acc, val) => acc + val, 0);
      expect(sum).toBeCloseTo(1.0, 10);
    });

    it('should produce different ratios on multiple calls (probabilistic)', () => {
      const ratios1 = calculateRandomMergeRatios(3);
      const ratios2 = calculateRandomMergeRatios(3);

      // Very unlikely to get exactly the same random ratios twice
      const areSame = ratios1.every((val, idx) =>
        Math.abs(val - ratios2[idx]) < 0.0001
      );

      expect(areSame).toBe(false);
    });

    it('should never produce zero ratios', () => {
      // Test multiple times for statistical confidence
      for (let i = 0; i < 10; i++) {
        const ratios = calculateRandomMergeRatios(5);
        ratios.forEach(ratio => {
          expect(ratio).toBeGreaterThan(0);
        });
      }
    });
  });

  describe('getPresetDescriptionSuffix', () => {
    beforeEach(() => {
      // Mock Date to get consistent results
      jest.useFakeTimers();
      jest.setSystemTime(new Date('2025-10-26'));
    });

    afterEach(() => {
      jest.useRealTimers();
    });

    it('should include github URL and date', () => {
      const config = getDefaultConfig();

      const result = getPresetDescriptionSuffix(config);

      expect(result).toContain('Generated by https://github.com/Fannon/u-he-preset-randomizer');
      expect(result).toContain('2025-10-26');
    });

    it('should include category when present', () => {
      const config = getDefaultConfig();
      config.category = 'Bass';

      const result = getPresetDescriptionSuffix(config);

      expect(result).toContain('Based on presets of category: Bass');
    });

    it('should not include category when absent', () => {
      const config = getDefaultConfig();

      const result = getPresetDescriptionSuffix(config);

      expect(result).not.toContain('Based on presets of category');
    });

    it('should handle boolean category value', () => {
      const config = getDefaultConfig();
      config.category = true;

      const result = getPresetDescriptionSuffix(config);

      expect(result).toContain('Based on presets of category: true');
    });

    it('should end with period', () => {
      const config = getDefaultConfig();

      const result = getPresetDescriptionSuffix(config);

      expect(result).toMatch(/\.$/);
    });
  });
});
